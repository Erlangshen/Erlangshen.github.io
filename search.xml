<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Rxjava2 和 Retrofit2 结合使用详解]]></title>
    <url>%2FAndroid%2Fretrofitandrxjava%2F</url>
    <content type="text"><![CDATA[不讲 rxjava 和 retrofit 而是直接上手 2 了，因为 2 封装的更好用的更多。 1. 观察者模式常见的 button 点击事件为例，button 是被观察者，listener 是观察者，setOnClickListener 过程是订阅，有了订阅关系后在 button 被点击的时候，监听者 listener 就可以响应事件。 这里的button.setOnClickListener(listener)看上去意思是被观察者订阅了观察者（杂志订阅了读者），逻辑上不符合日常生活习惯。其实这是设计模式的习惯，不必纠结，习惯了这种模式就利于理解观察者模式了。 2. RxJava 中的观察者模式 Observable：被观察者（ble 结尾的单词一般表示 可…的，可观察的） Observer：观察者（er 结尾的单词一般表示 …者，…人） subscribe：订阅 首先创建 Observable 和 Observer，然后 observable.subscribe(observer)，这样 Observable 发出的事件就会被 Observer 响应。一般我们不手动创建 Observable，而是由 Retrofit 返回给我们，我们拿到 Observable 之后只需关心如何操作 Observer 中的数据即可。不过为了由浅入深的演示，还是手动创建 Observable 来讲解。 2.1 创建 Observable常见的几种方式，不常用的不写了，因为我觉得这个模块不是重点。 var observable=Observable.create(ObservableOnSubscribe&lt;String&gt; {...}) var observable=Observable.just(...) var observable = Observable.fromIterable(mutableListOf(...)) 2.1.1 create()12345678var observable2=Observable.create(object :ObservableOnSubscribe&lt;String&gt;&#123; override fun subscribe(emitter: ObservableEmitter&lt;String&gt;) &#123; emitter.onNext("Hello ") emitter.onNext("RxJava ") emitter.onNext("GoodBye ") emitter.onComplete() &#125; &#125;) ObservableOnSubscribe和ObservableEmitter都是陌生人，这个要是详细讲涉及到源码分析，东西可就多了（主要是我不熟悉），所以可以理解成 ObservableOnSubscribe 是用来帮助创建 Observable 的，ObservableEmitter 是用来发出事件的（这些事件在观察者 Observer 中可以响应处理）。emitter 一次发射了三个事件，然后调用了 onComplete() 这些在下面讲观察者 Observer 时还会提到，一并讲解。 2.1.2 just1var observable=Observable.just("Hello","RxJava","GoodBye") 这句的效果等同于上面用 create 创建 observable，即 调用 3 次 onNext 后再调 onComplete。 2.1.3 fromIterable1var observable = Observable.fromIterable(mutableListOf("Hello","RxJava","GoodBye")) 这句的效果等同于上面用 create 创建 observable，即 调用 3 次 onNext 后再调 onComplete。 2.2 创建 Observer12345678910111213141516171819val observer = object : Observer&lt;String&gt; &#123; override fun onComplete() &#123; Log.e("abc", "-----onComplete-----") &#125; override fun onSubscribe(d: Disposable) &#123; Log.e("abc", "-----onSubscribe-----") &#125; override fun onNext(t: String) &#123; Log.e("abc", "-----onNext-----$t") &#125; override fun onError(e: Throwable) &#123; Log.e("abc", "-----onError-----$e") &#125; &#125;//订阅observable.subscribe(observer) log 打印情况： 12345-----onSubscribe----------onNext-----Hello-----onNext-----RxJava-----onNext-----GoodBye-----onComplete----- 可以看到，先是建立订阅关系，然后根据前面 observable 的发射顺序来打印 onNext，参数通过 onNext(t: String) 传进来，最后调用 onComplete，多说一句，在 just 和 fromIterable 的情况下，没有手动调用 Emitter，但是仍会先调用 onNext，最后调用 onComplete 2.3 Consumer 和 Action这两个词意思分别是消费者（可以理解为消费被观察者发射出来的事件）和行为（可以理解为响应被观察者的行为）。对于 Observer 中的 4 个回调方法，我们未必都能用得到，如果只需要用到其中的一部分，就需要 Consumer 和 Action 上场了。 有参数的onSubscribe、onNext、onError我们用 Consumer 来代替，无参的onComplete用 Action 代替： 2.3.1 subscribe(Consumer&lt;? super T&gt; onNext)123456789observable.subscribe(object :Consumer&lt;String&gt;&#123; override fun accept(t: String?) &#123; Log.e("abc", "-----onNext-----$t") &#125; &#125;)//打印-----onNext-----Hello-----onNext-----RxJava-----onNext-----GoodBye 说明一下，如果 subscribe 中我们只传一个对象参数，那只能是subscribe(Consumer&lt;? super T&gt; onNext)（onNext 方法），不能是 Action 或 Consumer&lt;? super Throwable&gt; onError、Consumer&lt;? super Disposable&gt; onSubscribe ==注意==：Consumer 中的回调方法名称是 accept，区别于前面的 onNext 2.3.2 subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError)带有两个 Consumer 参数，分别负责 onNext 和 onError 的回调。 123456789observable.subscribe(object : Consumer&lt;String&gt; &#123; override fun accept(t: String?) &#123; Log.e("abc", "-----onNext-----$t") &#125; &#125;, object : Consumer&lt;Throwable&gt; &#123; override fun accept(t: Throwable?) &#123; Log.e("abc", "-----onError-----$e") &#125; &#125;) 如果想要一个带有两个 Consumer 但是不是这种搭配（比如subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Disposable&gt; onSubscribe)），可以吗？答案是：不行 2.3.3 subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError,Action onComplete)带有三个参数，分别负责onNext、onError和onComplete的回调。 12345678910111213observable.subscribe(object : Consumer&lt;String&gt; &#123; override fun accept(t: String?) &#123; Log.e("abc", "-----onNext-----$t") &#125; &#125;, object : Consumer&lt;Throwable&gt; &#123; override fun accept(t: Throwable?) &#123; Log.e("abc", "-----onError-----$e") &#125; &#125;, object : Action &#123; override fun run() &#123; Log.e("abc", "-----onComplete-----") &#125; &#125;) 同样，三个参数只能有这一种搭配 ==注意==：Action 中的回调方法名称是 run，区别于前面的 onComplete 2.3.4 subscribe(Consumer&lt;? super T&gt; onNext, Consumer&lt;? super Throwable&gt; onError,Action onComplete, Consumer&lt;? super Disposable&gt; onSubscribe)这种情况和直接 new 出来的 Observer 效果一样。 12345678910111213141516observable2.subscribe(object : Consumer&lt;String&gt; &#123; override fun accept(t: String?) &#123; Log.e("abc", "-----onNext-----$t") &#125; &#125;, object : Consumer&lt;Throwable&gt; &#123; override fun accept(t: Throwable?) &#123; Log.e("abc", "-----onError-----$e") &#125; &#125;, object : Action &#123; override fun run() &#123; Log.e("abc", "-----onComplete-----") &#125; &#125;,object : Consumer&lt;Disposable&gt;&#123; override fun accept(t: Disposable?) &#123; Log.e("abc", "-----onSubscribe-----") &#125; &#125;) 3. 变换在上面的例子中，Observable 发送的都是 String 类型的数据，所以在 Observer 中接收的也都是 String，现实开发中的数据多种多样，而且有时候 Observable 提供的数据不是我们理想的情况，这种情况下就需要用到转换操作符。同样我们只讲常用的： 3.1 map比如我们想把上游的 Int 类型的数据转换成 String 可以这样操作： 1234567891011121314151617Observable.fromIterable(mutableListOf&lt;Int&gt;(1, 3, 5, 7, 8)) .map(object : Function&lt;Int, String&gt; &#123; override fun apply(t: Int): String &#123; return "zb$t" &#125; &#125;) .subscribe(object : Consumer&lt;String&gt; &#123; override fun accept(t: String?) &#123; Log.e("abc","-- $t --") &#125; &#125;)//Log日志-- zb1 ---- zb3 ---- zb5 ---- zb7 ---- zb8 -- 通过map操作符，Int 类型数据，到 Consumer 里已经成了 String（这里为了简单的只看数据就没用 Observer 而改用 Consumer，两者都可以）。这里面用到了Function，它的第一个泛型是 Observable 中发射的数据类型，第二个泛型是我们想要装换之后的数据类型，在 Function 的 apply 方法中手动完成数据的转化。示意图：map 把圆的变成了方的。 3.2 flatMap与 map 相似，不过 flatMap 返回的是一个 Observable，也就是说 Function 的第二个泛型固定了，就是 Observable，这样说不太好理解，看个例子：假如现在有多个学生，每个学生有多个科目，每个科目考了多次试，现在要打印所有的分数。单单只用 map 就不能直接搞定，试试吧 12345678910111213141516171819202122232425class Course(var name: String, var scores: MutableList&lt;Int&gt;)class Student(var name: String, var courses: MutableList&lt;Course&gt;)var stu1Course1 = Course("体育",mutableListOf(80, 81, 82))var stu1Course2 = Course("美术",mutableListOf(63, 62, 60))var stu1 = Student("StuA", mutableListOf(stu1Course1, stu1Course2))var stu2Course1 = Course("音乐",mutableListOf(74, 77, 79))var stu2Course2 = Course("希腊语",mutableListOf(90, 90, 91))var stu2 = Student("StuB", mutableListOf(stu2Course1, stu2Course2))Observable.just(stu1,stu2) .map(object :Function&lt;Student,MutableList&lt;Course&gt;&gt;&#123; override fun apply(t: Student): MutableList&lt;Course&gt; &#123; return t.courses &#125; &#125;) .subscribe(object :Consumer&lt;MutableList&lt;Course&gt;&gt;&#123; override fun accept(t: MutableList&lt;Course&gt;?) &#123; for (item in t!!)&#123; for (i in item.scores)&#123; Log.e("abc","---&gt;$i") &#125; &#125; &#125; &#125;) 通过两层 for 循环可以打印，这也是没办法的事，因为在 map 里面只能拿到 Course 集合。使用 flatMap 的情况是这样的： 123456789101112131415161718192021222324252627282930Observable.just(stu1, stu2) .flatMap(object : Function&lt;Student, ObservableSource&lt;Course&gt;&gt; &#123; override fun apply(t: Student): ObservableSource&lt;Course&gt; &#123; return Observable.fromIterable(t.courses) &#125; &#125;) .flatMap(object : Function&lt;Course, ObservableSource&lt;Int&gt;&gt; &#123; override fun apply(t: Course): ObservableSource&lt;Int&gt; &#123; return Observable.fromIterable(t.scores) &#125; &#125;) .subscribe(object : Consumer&lt;Int&gt; &#123; override fun accept(t: Int?) &#123; Log.e("abc", "---&gt; $t") &#125; &#125;)// log 打印 ---&gt; 80 ---&gt; 81 ---&gt; 82 ---&gt; 63 ---&gt; 62 ---&gt; 60 ---&gt; 74 ---&gt; 77 ---&gt; 79 ---&gt; 90 ---&gt; 90 ---&gt; 91 用了两次 flatMap，链式调用比缩进式更清晰。这里面的 flatMap 返回值类型的是 ObservableSource 并不是我们在前面提到的 Observable，查看 Observable 源码可以看到，它继承了 ObservableSource，所以这种多态用法是可以的。另外在 apply 中返回的Observable.fromIterable(t.courses)这一句不就是我们创建 Observable 的方式吗？简单的说，map 是把 Observable 发射的数据变换一下类型，flatMap 是把数据中集合/数组中的每个元素再次通过 Observable 发射。示意图：faltMap 把一系列圆的通过一系列的 Observable 变成了一系列方的。 图虽然画的丑，但是我想意思比较明白了。 3.3 filterfilter是过滤的意思，通过判断是否符合我们想要的逻辑，来决定是否发射事件，只有返回 true 的事件才被发射，其他的被抛弃。还以上面的例子为例，假如我们只想看 80 分以上的成绩可以这样过滤： 1234567891011121314151617181920212223242526272829Observable.just(stu1, stu2) .flatMap(object : Function&lt;Student, ObservableSource&lt;Course&gt;&gt; &#123; override fun apply(t: Student): ObservableSource&lt;Course&gt; &#123; return Observable.fromIterable(t.courses) &#125; &#125;) .flatMap(object : Function&lt;Course, ObservableSource&lt;Int&gt;&gt; &#123; override fun apply(t: Course): ObservableSource&lt;Int&gt; &#123; return Observable.fromIterable(t.scores) &#125; &#125;) .filter(object :Predicate&lt;Int&gt;&#123; override fun test(t: Int): Boolean &#123; return t &gt; 80 &#125; &#125;) .subscribe(object : Consumer&lt;Int&gt; &#123; override fun accept(t: Int?) &#123; Log.e("abc", "---&gt; $t") &#125; &#125;)// log 打印 ---&gt; 81 ---&gt; 82 ---&gt; 90 ---&gt; 90 ---&gt; 91 注意，filter 里面不是用 Function 了，而是 Predicate，这个单词是“基于…”的意思，基于 t &gt; 80，也就是选择大于 80 分的成绩。 4. 结合 Retrofit 使用前面 3 小节讲了很多，都是为了讲清楚 RxJava 的整个工作流程，还没涉及到线程切换。现实开发中更多的时候 Observable 是通过 Retrofit 返回给我们的。Retrofit 是一个网络请求框架，它基于 OkHttp3，做了更好的封装，结合 RxJava 用惯了的话可以大大提到开发效率。还是一样，我们只看怎么用，不涉及源码解读。 4.1 Retrofit 进行简单的 Get 请求12implementation &apos;com.squareup.retrofit2:retrofit:2.6.2&apos;implementation &apos;com.squareup.retrofit2:converter-gson:2.6.2&apos; 先引入依赖，然后我们请求一个知乎日报的新闻数据(点击查看数据：https://news-at.zhihu.com/api/4/news/latest)： 12345678910111213141516171819202122232425262728// ZhEntityclass ZhEntity &#123; var date: String? = null var stories: MutableList&lt;StoriesBean&gt;? = null var top_stories: MutableList&lt;TopStoriesBean&gt;? = null class StoriesBean &#123; var image_hue: String? = null var title: String? = null var url: String? = null var hint: String? = null var ga_prefix: String? = null var type: Int = 0 var id: Int = 0 var images: MutableList&lt;String&gt;? = null &#125; class TopStoriesBean &#123; var image_hue: String? = null var hint: String? = null var url: String? = null var image: String? = null var title: String? = null var ga_prefix: String? = null var type: Int = 0 var id: Int = 0 &#125;&#125; 12345678// ApiServiceimport retrofit2.Callimport retrofit2.http.GETimport retrofit2.http.Urlinterface ApiService &#123; @GET("news/latest") fun getLatestNews(): Call&lt;ZhEntity&gt;&#125; 12345678910111213141516// 调用val retrofit = Retrofit.Builder() .addConverterFactory(GsonConverterFactory.create()) .baseUrl("https://news-at.zhihu.com/api/4/") .build() val service: ApiService = retrofit.create(ApiService::class.java) val call: Call&lt;ZhEntity&gt; = service.getLatestNews() call.enqueue(object : Callback&lt;ZhEntity&gt; &#123; override fun onFailure(call: Call&lt;ZhEntity&gt;?, t: Throwable?) &#123; Log.e("abc", "--&gt; $t") &#125; override fun onResponse(call: Call&lt;ZhEntity&gt;?, response: Response&lt;ZhEntity&gt;?) &#123; Log.e("abc", "--&gt;$&#123;Gson().toJson(response?.body())&#125;") &#125; &#125;) 代码有点多，分别解释一下，ZhEntity 是实体类，ApiService 是一个接口，里面用注解的方式定义了一个方法 getLatestNews，@GET表示 Get 请求，由此可以想象肯定有@POST，@GET里面还有参数，这是请求地址 BaseUrl 后面的子文件夹。 getLatestNews 函数返回类型是 Call，这个是 Retrofit 定义用来请求网络的。第三段代码，现实创建了一个 Retrofit 对象，addConverterFactory(GsonConverterFactory.create())是把接口返回的 json 类型的数据转换成实体类的类型，这个东西在implementation &#39;com.squareup.retrofit2:converter-gson:2.6.2&#39;时被引入。 然后是一系列的 Call 调用 qnqueue 操作什么的，看得出，没有用 Rxjava 一样可以完成网络请求，而且代码不复杂，好了，本文到此结束。 好吧，我在扯淡。继续讲，有人说不喜欢 url 被截成两段，可以这样修改，效果完全相同： 12345678// ApiServiceimport retrofit2.Callimport retrofit2.http.GETimport retrofit2.http.Urlinterface ApiService &#123; @GET fun getLatestNews(@Url url:String): Call&lt;ZhEntity&gt;&#125; 12345678910111213141516// 调用val retrofit = Retrofit.Builder() .addConverterFactory(GsonConverterFactory.create()) .baseUrl("https://www.baidu.com") .build() val service: ApiService = retrofit.create(ApiService::class.java) val call: Call&lt;ZhEntity&gt; = service.getLatestNews("https://news-at.zhihu.com/api/4/news/latest") call.enqueue(object : Callback&lt;ZhEntity&gt; &#123; override fun onFailure(call: Call&lt;ZhEntity&gt;?, t: Throwable?) &#123; Log.e("abc", "--&gt; $t") &#125; override fun onResponse(call: Call&lt;ZhEntity&gt;?, response: Response&lt;ZhEntity&gt;?) &#123; Log.e("abc", "--&gt;$&#123;Gson().toJson(response?.body())&#125;") &#125; &#125;) baseUrl 还是要的，不过设置成其他值无所谓了，因为不会被请求。 4.2 Retrofit 结合 RxJava啰嗦了这么多，才讲到这里。抱歉水平有限，没办法用简单的语言说清复杂的问题。首先，引入依赖时多加一句对 RxJava 的支持： 123implementation &apos;com.squareup.retrofit2:retrofit:2.6.2&apos;implementation &apos;com.squareup.retrofit2:converter-gson:2.6.2&apos;implementation &apos;com.squareup.retrofit2:adapter-rxjava2:2.6.2&apos; 然后，我们的 getLatestNews 就可以直接返回一个 Observable 了！ 1234567import io.reactivex.Observableimport retrofit2.http.GETinterface ApiService &#123; @GET("news/latest") fun getLatestNews(): Observable&lt;ZhEntity&gt;&#125; 放心写，不会报错，有了 Observable，就好办了，轻车熟路： 1234567891011121314151617181920212223val retrofit = Retrofit.Builder() .addConverterFactory(GsonConverterFactory.create()) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .baseUrl("https://news-at.zhihu.com/api/4/") .build() val service: ApiService = retrofit.create(ApiService::class.java) val observable = service.getLatestNews() observable.subscribeOn(Schedulers.newThread()) .subscribe(object : Observer&lt;ZhEntity&gt; &#123; override fun onComplete() &#123; &#125; override fun onSubscribe(d: Disposable) &#123; &#125; override fun onNext(t: ZhEntity) &#123; Log.e("abc","--&gt;$&#123;Gson().toJson(t)&#125;") &#125; override fun onError(e: Throwable) &#123; Log.e("abc","--&gt;$e") &#125; &#125;) 除了 Observable 来源变了，其他与本文最早讲的 RxJava 没什么不同。非要说不同，有一点，多了一句subscribeOn(Schedulers.newThread())，下面讲讲这个。 4.3 线程切换 subscribeOn：定义 Observable 发射事件所处的线程 observeOn：定义转换/响应事件所处的线程（map、flatMap、Observer 等），可多次切换 线程切换比较常见，比如 子线程请求网络数据主线程更新 UI，subscribeOn和observeOn有哪些线程可以选择？它们又是怎样使用的？我们先看一个例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344Thread(object : Runnable &#123; override fun run() &#123; Log.e("abc","Thread当前线程：$&#123;Thread.currentThread().name&#125;") observable.subscribeOn(Schedulers.newThread()) .doOnNext(object :Consumer&lt;ZhEntity&gt;&#123; override fun accept(t: ZhEntity?) &#123; Log.e("abc","doOnNext当前线程：$&#123;Thread.currentThread().name&#125;") &#125; &#125;) .observeOn(Schedulers.io()) .flatMap(object :Function&lt;ZhEntity,ObservableSource&lt;ZhEntity.StoriesBean&gt;&gt;&#123; override fun apply(t: ZhEntity): ObservableSource&lt;ZhEntity.StoriesBean&gt; &#123; Log.e("abc","flatMap当前线程：$&#123;Thread.currentThread().name&#125;") return Observable.fromIterable(t.stories) &#125; &#125;) .observeOn(AndroidSchedulers.mainThread()) .subscribe(object : Observer&lt;ZhEntity.StoriesBean&gt; &#123; override fun onComplete() &#123; &#125; override fun onSubscribe(d: Disposable) &#123; Log.e("abc","onSubscribe当前线程：$&#123;Thread.currentThread().name&#125;") &#125; override fun onNext(t: ZhEntity.StoriesBean) &#123; Log.e("abc","Observer当前线程：$&#123;Thread.currentThread().name&#125;") Log.e("abc", "--&gt;$&#123;Gson().toJson(t)&#125;") &#125; override fun onError(e: Throwable) &#123; Log.e("abc", "--&gt;$e") &#125; &#125;) &#125; &#125;).start()// log 打印Thread当前线程：Thread-4onSubscribe当前线程：Thread-4doOnNext当前线程：RxNewThreadScheduler-1flatMap当前线程：RxCachedThreadScheduler-1Observer当前线程：mainObserver当前线程：mainObserver当前线程：main 这里面只有doOnNext没讲过，现在说说：每发送 onNext() 之前都会先回调这个方法，所以 doOnNext 和 Observable 的 subscribe（发射事件的方法）处于同一个线程。从这个例子可以看出： Observable 和 Observer 建立订阅关系是在当前线程中（Thread-4） subscribeOn决定 Observable 发射事件所处的线程（即 Retrofit 请求网络所在线程） 第一次observeOn决定 flatMap 所在的线程（RxCachedThreadScheduler-1） 再次observeOn决定 Observer 所在线程（Android 主线程 main） 所以每次调用observeOn就会切换线程，并且决定的是接下来的变换/响应的线程。多说一句，多次设置 subscribeOn，只有第一次生效。 线程可选值：线 程 名 称 | 说明 | -Schedulers.immediate() | 默认的 Scheduler,直接在当前线程运行，相当于不指定线程Schedulers.newThread() | 启用新线程，并在新线程执行操作Schedulers.io() | I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程Schedulers.computation() | 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPUAndroidSchedulers.mainThread() | Android 主线程 name 111 aaa bbb fff ggg name 111 aaa bbb fff ggg 4.4 Disposable 和 CompositeDisposable最后介绍一下这两个类，Disposable前文出现过，在 Observer 的 onSubscribe 函数中，有一个 Disposable 类型的参数：override fun onSubscribe(d: Disposable) {}，通过前面介绍我们知道，Observable 和 Observer 建立订阅关系时会调用 onSubscribe 方法，但是没有说这个参数的作用。 4.4.1 DisPosableDisposable 的 dispose() 函数可以用来解除订阅，这样就不会收到 Observable 发射的事件： 123456789101112131415161718192021var dis ?= nullval observable = Observable.fromIterable(mutableListOf("Hello", "RxJava", "GoodBye")) val observer = object : Observer&lt;String&gt; &#123; override fun onComplete() &#123; &#125; override fun onSubscribe(d: Disposable) &#123; dis=d Log.e("abc", "-----onSubscribe-----$d") &#125; override fun onNext(t: String) &#123; if (t=="Hello") dis.dispose() Log.e("abc", "-----onNext-----$t") &#125; override fun onError(e: Throwable) &#123; &#125; &#125;observable.subscribe(observer)// log 打印-----onNext-----Hello 可以看到，调用dis.dispose()后，就不在打印上游发射的”RxJava”和”GoodBye”了。 4.4.2 CompositeDisposableCompositeDisposable 可以用来管理多个 Disposable，通过add()方法添加 Disposable 对象，然后在 onDestroy 方法里面调用clear()或者dispose()来清除所有的 Disposable，这样可以防止内存泄漏。 12345678910val cDis = CompositeDisposable()// ...代码省略override fun onSubscribe(d: Disposable) &#123; cDis.add(d) &#125;// ...代码省略override fun onDestroy() &#123; super.onDestroy() cDis.clear() &#125; 多说一句，通过查看RxJava2CallAdapterFactory.create()源码可知，dispose()方法能主动断开 Observable 和 Observer 之间的连接，还能取消 Retrofit 的网络请求，所以放心的用吧。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>rxjava</tag>
        <tag>retrofit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mpvue + Vant Weapp 开发小程序之 van-checkbox 和 van-checkbox-group]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E5%92%8C%E5%B0%8F%E7%A8%8B%E5%BA%8F%2Fmpvue01%2F</url>
    <content type="text"><![CDATA[声明：我的文章很详(luo)细(suo)，适合基础特别差的人看。 1.引入首先，安装Vant Weapp： 1234567#根目录下打开命令提示符# 通过 npm 安装npm i vant-weapp -S --production# 通过 yarn 安装yarn add vant-weapp --production 然后，在app.json中这样引入： 1234"usingComponents": &#123; "van-checkbox": "/path/vant-weapp/checkbox/index", "van-checkbox-group": "/path/vant-weapp/checkbox-group/index" &#125; 蛤？找不到app.json？点击 快速上手，src根目录下就可以看到app.json了。 多说几句，&quot;van-checkbox&quot;: &quot;/path/vant-weapp/checkbox/index&quot;后半部分的路径，不同教程可能给的不同，我的项目path路径下啥都没有，但却可以这样引入，是因为我在webpack.base.conf.js中配置了： 123456789plugins: [ new CopyWebpackPlugin([ &#123; from: resolve(&apos;node_modules/vant-weapp/dist&apos;), to: path.resolve(config.build.assetsRoot, &apos;./path/vant-weapp&apos;), ignore: [&apos;.*&apos;] &#125; ]) ] 2.使用 van-checkbox 新建index.vue，直接上代码： 123456&lt;van-checkbox :value="isCheck" @change="onChange" name="ck" checked-color="#07c160"&gt;check&lt;/van-checkbox&gt; 与 Vant Weapp 官网的差别： 1234567// 官网（原生小程序）value=&quot;&#123;&#123; checked &#125;&#125;&quot;bind:change=&quot;onChange&quot;// mpvue:value=&quot;checked&quot; @change=&quot;onChange&quot; 然后是逻辑代码，官网给的是小程序代码，无法直接用在 mpvue 中： 1234567891011Page(&#123; data: &#123; checked: true &#125;, onChange(event) &#123; this.setData(&#123; checked: event.detail &#125;); &#125;&#125;); 改成: 123456789101112export default &#123; data () &#123; return &#123; isCheck: true, &#125; &#125;, methods: &#123; onChange (event) &#123; console.log(event.detail) &#125; &#125; &#125; 运行后打印的是undefined，说明一下，mpvue 中要把event.detail改成event.mp.detail，改过之后就可以正常打印 true 或者 false 了。让后把该值赋给变量 isCheck 就可以被其他地方获取到 van-checkbox 的选中状态了： 12345methods: &#123; onChange (event) &#123; this.isCheck = event.mp.detail &#125; &#125; 另外，有两个常用的属性：checked-color和shape，前者表示选中时的颜色，后者表示 van-checkbox 的形状(默认 round-圆形，可改成 square-正方形) 效果图： 3.使用 van-checkbox-group 直接看看 html 部分的代码： 1234567&lt;div&gt; &lt;van-checkbox-group :value="result" @change="onChangeGroup"&gt; &lt;van-checkbox name="ck" checked-color="#07c160" shape="square"&gt;check&lt;/van-checkbox&gt; &lt;van-checkbox name="ck2" checked-color="#cc66ff"&gt;check2&lt;/van-checkbox&gt; &lt;/van-checkbox-group&gt; &lt;p&gt;选中了：&#123;&#123;result&#125;&#125;&lt;/p&gt;&lt;/div&gt; 这个 van-checkbox-group 包含了两个 van-checkbox，我们想看到每选一个，下面就展示出选择的项目： van-checkbox-group 的选中值都放在:value:result中，每次勾选或者反选都会触发@change事件。逻辑代码部分： 12345678910111213export default &#123; data () &#123; return &#123; result: [] &#125; &#125;, methods: &#123; onChangeGroup (event) &#123; this.result = event.mp.detail &#125; &#125; &#125;&lt;/script&gt; max属性可以设置最大可选数，&lt;van-checkbox-group :value=&quot;result&quot; @change=&quot;onChange&quot; max=&quot;2&quot;&gt;...&lt;/van-checkbox-group&gt;表示最多可选 2 项。 4.搭配单元格组件使用首先引入 van-cell 和 van-cell-group： 123456&quot;usingComponents&quot;: &#123; &quot;van-cell&quot;: &quot;/path/vant-weapp/cell/index&quot;, &quot;van-cell-group&quot;: &quot;/path/vant-weapp/cell-group/index&quot;, &quot;van-checkbox&quot;: &quot;/path/vant-weapp/checkbox/index&quot;, &quot;van-checkbox-group&quot;: &quot;/path/vant-weapp/checkbox-group/index&quot; &#125; 然后这样使用： 12345678910111213&lt;van-checkbox-group :value="values" @change="groupclick"&gt; &lt;van-cell-group title="同学"&gt; &lt;van-cell v-for="(item, index) in list" :key="index" :title="'蔡徐坤 '+item" clickable @click="toggle" :data-name="item"&gt; &lt;van-checkbox :name="item"/&gt; &lt;/van-cell&gt; &lt;/van-cell-group&gt; &lt;/van-checkbox-group&gt; 说几点需要注意的细节： 与 Vant Weapp 官网的差别：123456&gt; // 官网（原生小程序）&gt; title=&quot;复选框 &#123;&#123; item &#125;&#125;&quot;&gt; &gt; // mpvue&gt; :title=&quot;&apos;蔡徐坤&apos;+item&quot;&gt; &lt;van-checkbox :name=&quot;item&quot;/&gt;是 &lt;van-cell&gt;&lt;/van-cell&gt;的子元素，这样才可以使用父元素中遍历的item 必须添加:data-name=&quot;item&quot;，否则子元素获取不到该数据 动态绑定数据，所以这些属性都是v-bind类型的：:title,:data-name,:name 逻辑代码部分： 1234567891011121314151617181920212223export default &#123; data () &#123; return &#123; list: ['a', 'b', 'c'], values: [] &#125; &#125;, methods: &#123; groupclick (event) &#123; this.values = event.mp.detail // 这句不用也可以 &#125;, toggle (event) &#123; let val = event.mp.currentTarget.dataset.name let index = this.values.indexOf(val) if (index &lt;= -1) &#123; this.values.push(val) &#125; else &#123; this.values.splice(index, 1) &#125; &#125; &#125; &#125; 注意一点就行，这样获取 van-checkbox 的name属性：let val = event.mp.currentTarget.dataset.name，效果图： 最后，源码地址]]></content>
      <categories>
        <category>前端和小程序</category>
      </categories>
      <tags>
        <tag>mpvue</tag>
        <tag>vue</tag>
        <tag>vant-weapp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[尹章晶拳打镇关西(选段)]]></title>
    <url>%2F%E6%81%B6%E6%90%9E%2Fvjpu01%2F</url>
    <content type="text"><![CDATA[三人来到酒楼楼上，拣个齐楚阁儿里坐下。提辖坐了主位，纪梦军对席，邓飞武下首坐了。酒保唱了喏，认得是尹提辖，便道：“提辖官人，打多少酒？”尹章晶道：“先打四角酒来。”一面铺下菜蔬果品按酒，又问道：“官人，吃甚下饭？”尹章晶道：“问甚么！但有，只顾卖来，一发算钱还你！这厮，只顾来聒噪！”酒保下去，随即烫酒上来，但是下口肉食，只顾将来摆一桌子。 三个酒至数杯，正说些闲话，较量些枪法，说得入港，只听得隔壁阁子里有人哽哽咽咽啼哭。尹章晶焦躁，便把碟儿盏儿都丢在楼板上。酒保听得，慌忙上来看时，见尹提辖气愤愤地。洒保抄手道：“官人要甚东西，分付卖来。”尹章晶道：“洒家要甚么！你也须认得洒家！却恁地教甚么人在间壁吱吱的哭，搅俺弟兄们吃洒？洒家须不曾少了你酒钱！”酒保道：“官人息怒。小人怎敢教人啼哭，打搅官人吃酒？这个哭的是绰酒座儿唱的父女两人，不知官人们在此吃酒，一时间自苦了啼哭。”尹提辖道：“可是作怪！你与我唤得他来。”酒保去叫。不多时，只见两个到来：前面一个十八九岁的妇人，背后一个五六十岁的老儿，手里拿串拍板，都来到面前。看那妇人，虽无十分容貌，也有些动人的颜色，拭着眼泪，向前来深深的道了三个万福。那老儿也都相见了。 尹章晶问道：“你两个是那里人家？为甚啼哭？”那妇人便道：“官人不知，容奴告禀。奴家是东京人氏，因同父母来渭州投奔亲眷，不想搬移南京去了。母亲在客店里染病身故。女父二人流落在此生受。此间有个财主，叫做‘镇关西’郑大官人，因见奴家，便使强媒硬保，要奴做妾 。谁想写了三千贯文书，虚钱实契，要了奴家身体。未及三个月，他家大娘子好生利害，将奴赶打出来，不容完聚，着落店主人家追要原典身钱三千贯，父亲懦弱，和他争执不得，他又有钱有势。当初不曾得他一文，如今那讨钱来还他？没计奈何，父亲自小教得奴家些小曲儿，来这里酒楼上赶座子，每日但得这些钱来，将大半还他，留些少女父们盘缠。这两日酒客稀少，违了他钱限，怕他来讨时受他羞耻。女父们想起这苦楚来，无处告诉，因此啼哭。不想误触犯了官人，望乞恕罪，高抬贵手！” 尹提辖又问道：“你姓甚么？在那个客店里歇？那个镇关西郑大官人在那里住？”老儿答道：“老汉姓金，排行第二。孩儿小字翠莲。郑大官人便是此间状元桥下卖肉的郑屠，绰号镇关西。老汉父女两个只在前面东门里尹家客店安下。”尹章晶听了道：“呸！俺只道那个郑大官人，却原来是杀猪的郑屠！这个腌臜泼才，投托着俺小种经略相公门下做个肉铺户，却原来这等欺负人！”回头看着纪梦军、邓飞武道：“你两个且在这里，等洒家去打死了那厮便来！”邓飞武、纪梦军抱住劝道：“哥哥息怒，明日却理会。”两个三回五次劝得他住。 尹章晶又道：“老儿，你来！洒家与你些盘缠，明日便回东京去，何如？”父女两个告道：“若能彀回乡去时，便是重生父母，再长爷娘。只是店主人家如何肯放？郑大官人须着落他要钱。”尹提辖道：“这个不妨事，俺自有道理。”便去身边摸出五两来银子，放在桌上，看着邓飞武道：“洒家今日不曾多带得些出来；你有银子，借些与俺，洒家明日便送还你。”邓飞武道：“直甚么，要哥哥还！”去包裹里取出一锭十两银子放在桌上。尹章晶看着纪梦军道：“你也借些出来与洒家。”纪梦军去身边摸出二两来银子。尹提辖看了见少，便道：“也是个不爽利的人！”尹章晶只把这十五两银子与了金老，分付道：“你父女两个将去做盘缠，一面收拾行李。俺明日清早来发付你两个起身，看那个店主人敢留你！”金老并女儿拜谢去了。尹章晶把这二两银子丢还了纪梦军。 三人再吃了两角酒，下楼来叫道：“主人家，酒钱洒家明日送来还你。”主人家连声应道：“提辖只顾自去，但吃不妨，只怕是提辖不来赊。”三个人出了尹家酒肆，到街上分手。邓飞武、纪梦军各自投客店去了。 只说尹提辖回到经略府前下处，到房里，晚饭也不吃，气愤愤地睡了。主人家又不敢问他。 再说金老得了这一十五两银子，回到店中，安顿了女儿，先去城外远处觅下一辆车儿，回来收拾了行李，还了房宿钱，算清了柴米钱，只等来日天明。当夜无事。次早五更起来，父女两个先打火做饭，吃罢，收拾了。天色微明，只见尹提辖大踏步走入店里来，高声叫道：“店小二，那里是金老歇处？”小二道：“金公，尹提辖在此寻你。”金公开了房门道：“提辖官人，里面请坐。”尹章晶道：“坐甚么！你去便去，等甚么！”金老引了女儿，挑了担儿，作谢提辖，便待出门。店小二拦住道：“金公，那里去？”尹章晶问道：“他少你房钱？”小二道：“小人房钱，昨夜都算还了；须欠郑大官人典身钱，着落在小人身上看管他哩。”尹提辖道：“郑屠的钱，洒家自还他，你放这老儿还乡去！”那店小二那里肯放。尹章晶大怒，揸开五指，去那小二脸上只一掌，打得那店小二口中吐血；再复一拳，打落两个当门牙齿。小二爬将起来，一道烟跑向店里去躲了。店主人那里敢出来拦他。金老父女两个忙忙离了店中，出城自去寻昨日觅下的车儿去了。 且说尹章晶寻思，恐怕店小二赶去拦截他，且向店里掇条凳子，坐了两个时辰。约莫金公去得远了，方才起身，迳到状元桥来。 且说郑屠开着两间门面，两副肉案，悬挂着三五片猪肉。郑屠正在门前柜身内坐定，看那十来个刀手卖肉。尹章晶走到门前，叫声“郑屠！”郑屠看时，见是尹提辖，慌忙出柜身来唱喏道：“提辖恕罪！”便叫副手掇条凳子来，“提辖请坐。”尹章晶坐下道：“奉着经略相公钧旨：要十斤精肉，切作臊子，不要见半点肥的在上面。”郑屠道：“使得，——你们快选好的切十斤去。”尹提辖道：“不要那等腌臜厮们动手，你自与我切。”郑屠道：“说得是，小人自切便了。”自去肉案上拣了十斤精肉，细细切做臊子。 那店小二把手帕包了头，正来郑屠报说金老之事，却见尹提辖坐在肉案门边，不敢扰来，只得远远的立住，在房檐下望。 这郑屠整整的自切了半个时辰，用荷叶包了道：“提辖，叫人送去？”尹章晶道：“送甚么！且住，再要十斤都是肥的，不要见些精的在上面，也要切做臊子。”郑屠道：“却才精的，怕府里要裹馄饨，肥的臊子何用？”尹章晶睁着眼道：“相公钧旨分付洒家，谁敢问他？”郑屠道：“是合用的东西，小人切便了。”又选了十斤实膘的肥肉，也细细的切做臊子，把荷叶包了。整弄了一早辰，却得饭罢时候。 那店小二那里敢过来，连那正要买肉的主顾也不敢拢来。 郑屠道：“着人与提辖拿了，送将府里去？”尹章晶道：“再要十斤寸软骨，也要细细地剁做臊子，不要见些肉在上面。”郑屠笑道：“却不是特地来消遣我？”尹章晶听得，跳起身来，拿着那两包臊子在手，睁着眼，看着郑屠道：“洒家特地要消遣你！”把两包臊子劈面打将去，却似下了一阵的“肉雨”。郑屠大怒，两条忿气从脚底下直冲到顶门，心头那一把无明业火焰腾腾的按捺不住，从肉案上抢了一把剔骨尖刀，托地跳将下来。尹提辖早拔步在当街上。 众邻居并十来个火家，那个敢向前来劝。两边过路的人都立住了脚，和那店小二也惊得呆了。 郑屠右手拿刀，左手便来要揪尹章晶；被这尹提辖就势按住左手，赶将入去，望小腹上只一脚，腾地踢倒在当街上。尹章晶再入一步，踏住胸脯，提起那醋钵儿大小拳头，看着这郑屠道：“洒家始投老种经略相公，做到关西五路廉访使，也不枉了叫做‘镇关西’！你是个卖肉的操刀屠户，狗一般的人，也叫做‘镇关西’！你如何强骗了金翠莲？”扑的只一拳，正打在鼻子上，打得鲜血迸流，鼻子歪在半边，却便似开了个油酱铺，咸的、酸的、辣的一发都滚出来。郑屠挣不起来，那把尖刀也丢在一边，口里只叫：“打得好！”尹章晶骂道：“直娘贼！还敢应口！”提起拳头来就眼眶际眉梢只一拳，打得眼棱缝裂，乌珠迸出，也似开了个彩帛铺，红的、黑的、紫的都绽将出来。 两边看的人惧怕尹提辖，谁敢向前来劝。 郑屠当不过，讨饶。尹章晶喝道：“咄！你是个破落户！若只和俺硬到底，洒家倒饶了你！你如今对俺讨饶，洒家偏不饶你！”又只一拳，太阳上正着，却似做了一个全堂水陆的道场，磬儿、钹儿、铙儿一齐响。尹章晶看时，只见郑屠挺在地上，口里只有出的气，没了入的气，动掸不得。 尹提辖假意道：“你这厮诈死，洒家再打！”只见面皮渐渐的变了。尹章晶寻思道：“俺只指望痛打这厮一顿，不想三拳真个打死了他。洒家须吃官司，又没人送饭，不如及早撒开。”拔步便走，回头指着郑屠尸道：“你诈死，洒家和你慢慢理会！”一头骂，一头大踏步去了。 街坊邻居并郑屠的火家，谁敢向前来拦他。 尹提辖回到下处，急急卷了些衣服盘缠，细软银两，但是旧衣粗重都弃了；提了一条齐眉短棒，奔出南门，一道烟走了。]]></content>
      <categories>
        <category>恶搞</category>
      </categories>
      <tags>
        <tag>尹章晶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dagger2 中使用 AndroidInjection 优化注入流程]]></title>
    <url>%2FAndroid%2Fandroidinjection%2F</url>
    <content type="text"><![CDATA[每个 Activity 如果都需要手动inject(this)有点繁琐，com.google.dagger:dagger-android中包含AndroidInjection类可以优化注册。 1.在 BaseActivity 中注册123456abstract class BaseActivity:AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; AndroidInjection.inject(this) super.onCreate(savedInstanceState) &#125;&#125; 注意一定要在super.onCreate(savedInstanceState)之前。其他 Activity 继承 BaseActivity 即可。同理，BaseFragment 也要这样操作，大同小异。这里以 v4 包的 Fragment 举例： 123456abstract class BaseFragment:Fragment() &#123; override fun onAttach(context: Context?) &#123; AndroidSupportInjection.inject(this) super.onAttach(context) &#125;&#125; 与 Activity 不同，这里在 onAttach 中注册。 2.创建 MainActivitySub12345@Subcomponent(modules = [(StudentModule::class)])interface MainActivitySub : AndroidInjector&lt;MainActivity&gt; &#123; @Subcomponent.Builder abstract class Builder:AndroidInjector.Builder&lt;MainActivity&gt;()&#125; 这里多说几句，StudentModule 是 Student 类对应的 Module，Student 类需要注入 MainActivity，MainActivity 继承自 BaseActivity。这几个类简单就不贴了，详情见 源码。如果项目中有 Fragment，那么它对应的 Sub 接口这样写： 12345@Subcomponent(modules = [(PersonModule::class)])interface TestFragmentSub:AndroidInjector&lt;TestFragment&gt;&#123; @Subcomponent.Builder abstract class Builder:AndroidInjector.Builder&lt;TestFragment&gt;()&#125; 上面这两个接口都使用了 Builder 模式。 3.创建 ActivityModule1234567@Module(subcomponents = [(MainActivitySub::class)])abstract class ActivityModule &#123; @Binds @IntoMap @ActivityKey(MainActivity::class) abstract fun bindMainActivity(builder: MainActivitySub.Builder): AndroidInjector.Factory&lt;out Activity&gt;&#125; 所有 Activity 都要在 ActivityModule 中添加： 1@ActivityKey(XXXActivity::class) 每个 Activity 都要建立对应的 XXXActivitySub 接口(上面第 2 步)，而且这些 XXXActivitySub 接口都要添加到 ActivityModule 的subcomponents中： 1@Module(subcomponents = [(XXXActivitySub::class),(YYYActivitySub::class)]) FragmentModule 也是一样的套路： 1234567@Module(subcomponents = [(TestFragmentSub::class)])abstract class FragmentModule &#123; @Binds @IntoMap @FragmentKey(TestFragment::class) abstract fun bindTestFragment(builder: TestFragmentSub.Builder): AndroidInjector.Factory&lt;out Fragment&gt;&#125; 4.创建 ApplicationSub1234@Component(modules = [(ActivityModule::class), (FragmentModule::class)])interface ApplicationSub &#123; fun inject(app: MyApp)&#125; ApplicationSub 管理 ActivityModule 和 FragmentModule，而这两个类管理所有的 Activity 和 Fragment，这样，就只需要在 Application 中初始化就好了。 5.初始化1234567891011121314151617181920class MyApp : Application(), HasActivityInjector, HasSupportFragmentInjector &#123; @Inject lateinit var activityInjector: DispatchingAndroidInjector&lt;Activity&gt; @Inject lateinit var fragmentInjector: DispatchingAndroidInjector&lt;Fragment&gt; override fun onCreate() &#123; super.onCreate() DaggerApplicationSub.create().inject(this) &#125; override fun activityInjector(): DispatchingAndroidInjector&lt;Activity&gt; &#123; return activityInjector &#125; override fun supportFragmentInjector(): DispatchingAndroidInjector&lt;Fragment&gt; &#123; return fragmentInjector &#125;&#125; 6.其他说明 我使用的开发环境是gradle:3.1.2 + kotlin_version = &#39;1.2.30&#39;,需要在 app.gradle 里面添加apply plugin: &#39;kotlin-kapt&#39; 使用针对 Android 的 dagger 地址： 123kapt 'com.google.dagger:dagger-compiler:2.12'implementation 'com.google.dagger:dagger-android:2.12'implementation 'com.google.dagger:dagger-android-support:2.12' Rebuild 的时候会提示如下红色日志，这个不影响，可以直接运行项目： 12345Folder D:\workspace\Dagger2Sample-master\app\build\generated\source\kaptKotlin\debugFolder D:\workspace\Dagger2Sample-master\app\build\generated\source\kaptKotlin\release3rd-party Gradle plug-ins may be the cause 最后，源码地址 其他几篇的链接：Dagger2 中的 QualifierDagger2 中的 Scope、dependenciesDagger2 中的 SubComponentDagger2 中的 Binds、IntoSet、IntoMap]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>dagger2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dagger2 中的 Binds、IntoSet、IntoMap]]></title>
    <url>%2FAndroid%2Fbinds%2F</url>
    <content type="text"><![CDATA[1.@Binds使用@Inject初始化对象时有一种特殊情况：需要初始化的是接口的实例，这时候需要特殊处理一下，就需要用到@Binds 12345@Moduleinterface IMainViewModule &#123; @Binds abstract fun provideIMainView(main: IMainViewImpl): IMainView&#125; 这里使用 provideXXX() 方式提供接口实例，说明几点： 方法中必须有参数且只能有一个，是接口的实现类 实现类必须提供@Inject的构造或 Module中@Provides形式提供 方法是抽象方法，不必写方法体 使用@Binds代替@Provides 由于方法是抽象的，所以类也要抽象或接口 IMainViewImpl.kt 的代码： 1class IMainViewImpl @Inject constructor() : IMainView 2.@IntoSet使用注入形式初始化 Set 集合时，可以在 Module 中多次定义一系列返回值类型相同的方法： 12345678910@Moduleclass AnimalModule &#123; @IntoSet @Provides fun provideElephant() = Animal("大象") @Provides @IntoSet fun provideMonkey() = Animal("猴子")&#125; Animal.kt 代码： 1class Animal(var name: String) 上面的 provideElephant() 和 provideMonkey() 返回值类型都是 Animal，都使用了@IntoSet注释，多说一句，@Provides当然也要有，如果是接口用@Binds。初始化并使用： 12345678@Injectlateinit var set: MutableSet&lt;Animal&gt;...//代码省略set.forEach &#123; Log.i("Main", "--- $&#123;it.name&#125; ---")&#125; kotlin 里面 MutableSet 代替 Java 中的 Set，上面代码运行可以输出： 12--- 大象 ------ 猴子 --- 3.@IntoMap与@IntoSet区别不大，Map 多了一个 key 123456789@Provides@IntoMap@IntKey(0)fun provideFish() = Animal("鱼")@Provides@IntoMap@IntKey(1)fun provideHuman() = Animal("人") @IntKey里面就是 Map 中的 key，providesXXX() 返回值是 key 对应的 value，如果 key 是 String 类型的，则使用@StringKey()输入 key，此外，还可以自定义 key： 12345@Documented@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)@MapKeyannotation class ZhuangBiKey(val f: Float) 初始化 map 并使用： 12345678@Injectlateinit var map: Map&lt;Int, Animal&gt;...//代码省略map.forEach &#123; Log.i("Main", "--- key:$&#123;it.key&#125;\nvalue:$&#123;it.value.name&#125; ---") &#125; 最后，说实话我觉得这样初始化一个 Set 或者 Map 效率不高，只不过为了别人这样写我们能看懂而已。其实我觉得整个 dagger2 都不咋地（发布时删掉这句）。 其他几篇的链接：Dagger2 中的 QualifierDagger2 中的 Scope、dependenciesDagger2 中的 SubComponentDagger2 中使用 AndroidInjection 优化注入流程]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>dagger2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dagger2 中的 SubComponent]]></title>
    <url>%2FAndroid%2Fsubcomponent%2F</url>
    <content type="text"><![CDATA[两个 Component 之间除了 dependencies 依赖方式以外，还可以使用 Subcomponent 方式。比如说 SeeComponent 想要依赖 AnimalComponent，我们可以这样操作： 第一步，在 SeeComponent 中使用@Subcomponent注解：1234@Subcomponentinterface SeeComponent &#123; fun inject(firstActivity: SeeActivity)&#125; 第二步，在 AnimalComponent 中定义返回值类型为 SeeComponent 的方法：123456@ZhuangBiScope@Component(dependencies = [(BComponent::class)], modules = [(AppModule::class), (AnimalModule::class)])interface AnimalComponent &#123; fun inject(secondActivity: SecondActivity) fun getSeeComponent(): SeeComponent&#125; 第三步，初始化并使用：12345678910111213class SeeActivity : FragmentActivity() &#123; @Inject lateinit var sharedPreferences: SharedPreferences @Inject lateinit var stu: Student override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) (application as DaggerApplication).animalComponent?.getSeeComponent()?.inject(this) Log.e("abc", "---&gt; $sharedPreferences") Log.e("abc", "---&gt; $stu") &#125;&#125; animalComponent 调用 getSeeComponent() 得到 SeeComponent 实例，然后就可以 inject 到 SeeActivity 中。Subcomponent完全继承 Component 中的全部依赖。 和 dependencies 的区别： 被依赖的 Component 不需要显示声明 Module 中对应的 provideXXX() 方法 初始化的时候不需要使用 DaggerXXXComponent 创建被依赖的 Component 对象 dependencies：被依赖的 Component 有 Scope 修饰时，依赖方必须使用 Scope 且不可与前者的 Scope 相同； Subcomponent：被依赖的 Component 有 Scope 修饰时，依赖方可以不使用 Scope，也可以使用 Scope 但不能与前者的 Scope 相同； 相同点是：被依赖的 Component 没有 Scope 修饰时，依赖方是否使用 Scope 没有要求。 最后项目源码 其他几篇的链接：Dagger2 中的 QualifierDagger2 中的 Scope、dependenciesDagger2 中使用 AndroidInjection 优化注入流程Dagger2 中的 Binds、IntoSet、IntoMap]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>dagger2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dagger2 中的 Scope、dependencies]]></title>
    <url>%2FAndroid%2Fscope%2F</url>
    <content type="text"><![CDATA[Scope中文意思是范围，Dagger2 中的@Singleton是 Scope 的一种默认实现，点进去可以看到： 1234@Scope@Documented@Retention(RUNTIME)public @interface Singleton &#123;&#125; 上面是 Java 方式，如果我们自定义一个 Scope 就很简单了（kotlin 语言）： 1234@Documented@Scope@Retention(RetentionPolicy.RUNTIME)annotation class ZhuangBiScope 一个 Component 依赖另一个 Component 时需要用到 Scope，至于为什么 Component 之间要互相依赖，简单说下:一个项目里有很多功能模块，很多的 Activity，每个 Activity 都有对应的 Component，那么每个 Component 再对应多个 Module，最终工程会很庞大。有些 Module 可以共用，所以就需要dependencies关键字来依赖别的 Component。 比如 AnimalComponent 要依赖 BComponentAnimalComponent.kt 12345@ZhuangBiScope@Component(dependencies = [(BComponent::class)],modules = [(AppModule::class), (AnimalModule::class)])interface AnimalComponent &#123; fun inject(secondActivity: SecondActivity)&#125; AnimalComponent 需要依赖 BComponent，则@ZhuangBiScope注解在 AnimalComponent 上面。另外，AnimalComponent 包含的 AppModule 和 AnimalModule 里面的provideXX()方法如果有使用 Scope 修饰的（如 Singleton、ZhuangBiScope），则 AnimalComponent 也要用同样的 Scope 注解。且包含在同一个 Component 下的不同 Module 中provideXX()必须使用相同的 Scope。 AppModule.kt 123456@Moduleclass AppModule(var myApp: Application) &#123; @Provides @ZhuangBiScope fun providesApplication(): Application = myApp&#125; AnimalModule.kt 123456789101112131415161718192021222324@Moduleclass AnimalModule &#123; @Provides @ZhuangBiScope fun providesDog(): Dog &#123; Log.e("abc", "----- AnimalModule Dog -----") return Dog() &#125; @Provides @Tested("dog") @ZhuangBiScope fun providesCat(dog: Dog): Cat &#123; Log.e("abc", "----- AnimalModule Cat withdog -----") return Cat(dog) &#125; @Provides @Tested("dog2") fun providesCat2(dog: Dog): Cat &#123; Log.e("abc", "----- AnimalModule Cat withdog2 -----") return Cat(dog) &#125;&#125; 上面的 providesCat2() 方法没有任何 Scope 注解。接下来我们看看 BComponent： 12345678@Singleton@Component(modules = [(PersonModule::class), (StudentModule::class)])interface BComponent &#123; fun inject(bActivity: BActivity) fun person(): Person fun provideStudent(): Student// fun test(): String//会报错&#125; 包含两个 Module，一开始我只写了第一行的fun inject(bActivity: BActivity)结果总是报错，在这里卡了很久。需要说明的是: 当一个 Component 给别的 Component 依赖时，被依赖的 Component 要定义一些方法。这些方法的返回值类型和它包含的 Module 中方法返回类型相同。 只有暴露的方法才能在依赖方的 Component 中使用。 所有的暴露给依赖方的方法都是无参的。 不能有多余的自定义方法（例如上面的 test 方法），因为多余的在 Module 中找不到对应方法。 举例说明，BComponent 包含 PersonModule 和 StudentModule，两者分别包含： 123456@Singleton@Providesfun providePerson(): Person = Person()@Providesfun provideStudent(): Student = Student() 当 AnimalComponent 所 inject 的类中需要用到上面这两个实例的时候，就需要在 BComponent 中注册两个方法给 inject 的类使用(方法名叫什么都无所谓)： 12fun person(): Personfun provideStudent(): Student 这样才可以在 AnimalComponent 所 inject 的类中使用@Inject初始化 Person 和 Student 对象。 最后项目源码 其他几篇的链接：Dagger2 中的 SubComponentDagger2 中的 QualifierDagger2 中使用 AndroidInjection 优化注入流程Dagger2 中的 Binds、IntoSet、IntoMap]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>dagger2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dagger2 中的 Qualifier]]></title>
    <url>%2FAndroid%2Fqualifier%2F</url>
    <content type="text"><![CDATA[Dagger2 中创建实例对象有两种方式： Inject 维度：通过用 Inject 注解构造函数 Module 维度：通过工厂模式的 Module 创建 其中，Module 的优先级比 Inject 高。基于同样维度的不同实例，比如@Inject A(){}和@Inject A(B b){}，系统就会抱错，这种情况叫做依赖注入迷失。 Qualifier限定符 就是解决依赖注入迷失的。 1.定义限定符注解 java 中的方式： 123456@Qualifier@Documented@Retention(RetentionPolicy.RUNTIME)public @interface Named &#123; String name() default "";&#125; kotlin 中的方式： 1234@Qualifier@Documented@Retention(RetentionPolicy.RUNTIME)annotation class Named(val name: String) 2.Module 中使用12345678910111213141516@Provides@Named("dog")@Singletonfun providesAnimal(): Dog &#123; Log.e("abc", "----- dog -----") return Dog()&#125; @Provides@Named("dog2")@Singletonfun providesAnimal2(): Dog &#123; Log.e("abc", "----- dog2 -----") return Dog()&#125; 3.实例化1234567@Inject@field:Named("dog")lateinit var dog: Dog@Inject@field:Named("dog2")lateinit var dog2: Dog 根据打印的内容可以知道，创建对象 dog 和 dog2 的时候分别调用了 providesAnimal() 和 providesAnimal2()。说明：如果用@Named(&quot;xx&quot;)代替@field:Named(&quot;xx&quot;)会报错，因为代码编译为 Java 字节码的时候会对应三个目标元素：一个是变量本身、还有 getter 和 setter，Kotlin 不知道这个变量的注解应该使用到哪个目标上。使用 field 关键字是告诉 Kotlin 所注解的目标是哪个。 最后项目源码 其他几篇的链接：Dagger2 中的 SubComponentDagger2 中的 Scope、dependenciesDagger2 中使用 AndroidInjection 优化注入流程Dagger2 中的 Binds、IntoSet、IntoMap]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>dagger2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 水印相机开发]]></title>
    <url>%2FAndroid%2Fwatercamera%2F</url>
    <content type="text"><![CDATA[水印相机是自定义相机的一种，实现方法有很多，我看了很多别人的做的很漂亮，我做的就很普通了，不过总算是实现了拍照加水印的功能。 我这边用到了SurfaceView,有人没用这个也做出来水印相机，个人觉得还是SurfaceView更方便一点（不接受反驳）。 先看看效果：原图太大，我做了压缩，所以动图显得模糊。 第一步，我们想一进入就打开相机预览，这个怎么做呢？相机功能由android.hardware.Camera类实现，但是需要有一个预览载体，这里就用SurfaceView，而且需要辅助类SurfaceHolder,首先，我们的 Activity 要实现SurfaceHolder.Callback接口： 1public class WaterCameraActivity extends AppCompatActivity implements SurfaceHolder.Callback 第二步，关联SurfaceHolder： 12345678private SurfaceView mSv;private SurfaceHolder mSurfaceHolder;mSurfaceHolder = mSv.getHolder();mSurfaceHolder.setKeepScreenOn(true);mSurfaceHolder.setFormat(PixelFormat.TRANSPARENT);mSurfaceHolder.addCallback(this);// 为了实现照片预览功能，需要将SurfaceHolder的类型设置为PUSH,这样画图缓存就由Camera类来管理，画图缓存是独立于Surface的mSurfaceHolder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS); 实现SurfaceHolder.Callback接口有三个方法需要重写： 123456789101112@Override public void surfaceCreated(SurfaceHolder holder) &#123; &#125; @Override public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123; &#125; @Override public void surfaceDestroyed(SurfaceHolder holder) &#123; &#125; 只要SurfaceView显示，就会调用surfaceCreated()，不显示就会调用surfaceDestroyed()。因此可以在surfaceCreated()中初始化相机，并展示预览界面；在surfaceDestroyed()中释放相机资源。第三步，初始化相机 123456789101112131415161718192021222324252627282930313233343536373839404142434445mCamera = Camera.open(0);//0-后摄像头，1-前摄像头Camera.getCameraInfo(0, cameraInfo);Camera.Parameters parameters = mCamera.getParameters();// 设置图片格式parameters.setPictureFormat(ImageFormat.JPEG);// 设置照片质量parameters.setJpegQuality(100);// 首先获取系统设备支持的所有颜色特效，如果设备不支持颜色特性将返回一个null， 如果有符合我们的则设置List&lt;String&gt; colorEffects = parameters.getSupportedColorEffects();Iterator&lt;String&gt; colorItor = colorEffects.iterator();while (colorItor.hasNext()) &#123; String currColor = colorItor.next(); if (currColor.equals(Camera.Parameters.EFFECT_SOLARIZE)) &#123; parameters.setColorEffect(Camera.Parameters.EFFECT_AQUA); break; &#125;&#125;// 获取对焦模式List&lt;String&gt; focusModes = parameters.getSupportedFocusModes();if (focusModes.contains(Camera.Parameters.FOCUS_MODE_AUTO)) &#123; // 设置自动对焦 parameters.setFocusMode(Camera.Parameters.FOCUS_MODE_CONTINUOUS_VIDEO);&#125;// 设置闪光灯自动开启List&lt;String&gt; flashModes = parameters.getSupportedFlashModes();if (flashModes.contains(Camera.Parameters.FLASH_MODE_AUTO)) &#123; // 自动闪光 parameters.setFlashMode(Camera.Parameters.FLASH_MODE_AUTO);&#125;mCamera.setDisplayOrientation(setCameraDisplayOrientation());// 设置显示mCamera.setPreviewDisplay(mSurfaceHolder);List&lt;Camera.Size&gt; photoSizes = parameters.getSupportedPictureSizes();//获取系统可支持的图片尺寸int width = 0, height = 0;for (Camera.Size size : photoSizes) &#123; if (size.width &gt; width) width = size.width; if (size.height &gt; height) height = size.height;&#125;parameters.setPictureSize(width, height);// 设置完成需要再次调用setParameter方法才能生效mCamera.setParameters(parameters);// 开始预览mCamera.startPreview(); 这样就可以预览相机界面了，多说一点，我是在小米 8 手机调试的，照片很清晰，拍出来的照片有 8M 多大，但是换成荣耀 8，图片只有几十 Kb，很不清楚。单步调试的时候可以发现，parameters.getSupportedPictureSizes()这里获取的集合，小米和荣耀排序方式是不一样的，一个是清晰度由低到高，另一个由高到低。所以才改成上面代码中都取最大值： 12345int width = 0, height = 0;for (Camera.Size size : photoSizes) &#123; if (size.width &gt; width) width = size.width; if (size.height &gt; height) height = size.height;&#125; 第四步，拍照 123456789101112131415161718192021222324mCamera.takePicture(null, null, new android.hardware.Camera.PictureCallback() &#123; @Override public void onPictureTaken(byte[] data, android.hardware.Camera camera) &#123;//data 将会返回图片的字节数组 bitmap = BitmapFactory.decodeByteArray(data, 0, data.length); if (bitmap != null) &#123; Matrix m = new Matrix(); m.postRotate(90); bitmap = Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), m, true); bitmap = compressImage(bitmap); loadingTv.setVisibility(View.GONE); cameraBtn.setVisibility(View.INVISIBLE); cancelBtn.setVisibility(View.VISIBLE); sureBtn.setVisibility(View.VISIBLE); wordTv.setVisibility(View.INVISIBLE); dateTv.setVisibility(View.INVISIBLE); bitmap = addWater(bitmap); pictureLinear.setVisibility(View.VISIBLE); mSv.setVisibility(View.INVISIBLE); pictureIv.setImageBitmap(bitmap); &#125; else &#123; releaseCamera(); &#125; &#125; &#125;); 手动调用相机拍出来的照片是旋转了 270 度的，所以要再旋转 90 度，才是正常视角m.postRotate(90)。第五步，加水印操作 addWater(bitmap)： 1234567891011121314151617181920212223242526272829303132333435363738android.graphics.Bitmap.Config bitmapConfig = mBitmap.getConfig();if (bitmapConfig == null) &#123; bitmapConfig = android.graphics.Bitmap.Config.ARGB_8888;&#125;//获取原始图片与水印图片的宽与高int mBitmapWidth = mBitmap.getWidth();int mBitmapHeight = mBitmap.getHeight();DisplayMetrics dm = getResources().getDisplayMetrics();float screenWidth = dm.widthPixels;//1080float mBitmapWidthF = mBitmapWidth;times = mBitmapWidthF / screenWidth;Bitmap mNewBitmap = Bitmap.createBitmap(mBitmapWidth, mBitmapHeight, bitmapConfig);Canvas canvas = new Canvas(mNewBitmap);//向位图中开始画入MBitmap原始图片canvas.drawBitmap(mBitmap, 0, 0, null);Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);paint.setColor(Color.WHITE);paint.setDither(true); //获取跟清晰的图像采样paint.setFilterBitmap(true);//过滤一些paint.setTextSize(sp2px(this, 22) * times);String text = "装逼水印";Rect bounds = new Rect();paint.getTextBounds(text, 0, text.length(), bounds);float textW = paint.measureText(text);float x = (mBitmapWidth / 2) - (textW / 2);float textH = -paint.ascent() + paint.descent();canvas.drawText(text, x, (mBitmapHeight * 3 / 4), paint);//mBitmapWidth=3024paint.setTextSize(sp2px(this, 20) * times);paint.getTextBounds(date, 0, date.length(), bounds);textW = paint.measureText(date);x = (mBitmapWidth / 2) - (textW / 2);canvas.drawText(date, x, (mBitmapHeight * 3 / 4) + textH, paint);canvas.save(Canvas.ALL_SAVE_FLAG);return mNewBitmap; 说明几点： 1.一开始设置字体大小是 22sp，但是没有显示水印，后来近距离仔细看有水印，只是字体太小，用了 sp 转 px，还是很小，最后发现图片的宽比手机屏宽要大得多，考虑这个倍数，计算出来，字体就可以正常显示了：times = mBitmapWidthF / screenWidth 2.字体居中显示：paint.measureText(text)可以计算水印的宽度，屏宽一半减水印宽的一半，就是水印最左端的 x 坐标：高度我这边是从屏高 3/4 处开始绘制，所以最终就是居中显示在屏幕中下方： 12float x = (mBitmapWidth / 2) - (textW / 2);canvas.drawText(text, x, (mBitmapHeight * 3 / 4), paint); 3.显示两行水印，并且都居中：下面水印的 y 坐标 = 上面水印 y 坐标 + 上面水印的高度，上面水印高度计算：float textH = -paint.ascent() + paint.descent() 4.图片拍出来很大，压缩一下： 1234567891011ByteArrayOutputStream baos = new ByteArrayOutputStream();image.compress(Bitmap.CompressFormat.JPEG, 100, baos);// 质量压缩方法，这里100表示不压缩，把压缩后的数据存放到baos中int options = 98;while (baos.toByteArray().length / 1024 &gt; 3072) &#123; // 循环判断如果压缩后图片是否大于 3Mb,大于继续压缩 baos.reset(); // 重置baos即清空baos image.compress(Bitmap.CompressFormat.JPEG, options, baos);// 这里压缩options%，把压缩后的数据存放到baos中 options -= 2;// 每次都减少2&#125;ByteArrayInputStream isBm = new ByteArrayInputStream(baos.toByteArray());// 把压缩后的数据baos存放到ByteArrayInputStream中Bitmap bitmap = BitmapFactory.decodeStream(isBm, null, null);// 把ByteArrayInputStream数据生成图片return bitmap; 第六步，保存水印图： 1234567891011FileOutputStream outStream = null;String filePath = Environment.getExternalStorageDirectory().getPath() + File.separator + "testPhoto";String fileName = filePath + File.separator + String.valueOf(System.currentTimeMillis()) + ".jpg";File file = new File(fileName);if (!file.exists()) file.getParentFile().mkdirs();outStream = new FileOutputStream(fileName);bitmap.compress(Bitmap.CompressFormat.JPEG, 100, outStream);if (outStream != null) outStream.close();// 最后通知图库更新WaterCameraActivity.this.sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.parse("file://" + fileName)));Toast.makeText(this, "文件已保存至:" + fileName, Toast.LENGTH_LONG).show(); 效果图： 清晰度可以的。 附上源码：点击获取谢谢！]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>水印相机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidStudio 和 EclipseADT 创建项目时的 aidl 通信]]></title>
    <url>%2FAndroid%2Faidl%2F</url>
    <content type="text"><![CDATA[Eclipse 用的人不多，在使用 aidl 实现进程间通信的时候，studio 和 eclipse 还是有点儿区别的。比如现在我们要实现一个求和功能，client 只负责输入，service 负责计算功能。client 界面： 1.使用 Eclipse 编写 Service 代码service 目录结构：Calculate.aidl: 12345package com.demo.aidl;interface Calculate&#123; double doCalculate(double a,double b);&#125; CalculateService: 123456789101112131415161718192021222324package com.demoserver;import android.app.Service;import android.content.Intent;import android.os.IBinder;import android.os.RemoteException;import com.demo.aidl.Calculate;public class CalculateService extends Service &#123; @Override public IBinder onBind(Intent arg0) &#123; return mBinder; &#125; private final Calculate.Stub mBinder = new Calculate.Stub() &#123; @Override public double doCalculate(double a, double b) throws RemoteException &#123; return a + b; &#125; &#125;;&#125; 注意：CalculateService 需要在清单文件里注册并设置 action 1234567&lt;service android:name="com.demoserver.CalculateService" android:exported="true" &gt; &lt;intent-filter&gt; &lt;action android:name="com.demoserver.CalculateService" /&gt; &lt;/intent-filter&gt;&lt;/service&gt; 2.使用 Eclipse 编写 client：这里的 Calculate.aidl 都必须和 Service 端一样，界面太简单，不再贴出，MainActivity 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class MainActivity extends Activity &#123; private EditText numEt1, numEt2; private Button calculateBtn; private Calculate mService; private ServiceConnection conn = new ServiceConnection() &#123; @Override public void onServiceDisconnected(ComponentName arg0) &#123; mService = null; &#125; @Override public void onServiceConnected(ComponentName arg0, IBinder arg1) &#123; mService = Calculate.Stub.asInterface(arg1); &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); numEt1 = (EditText) findViewById(R.id.numEt1); numEt2 = (EditText) findViewById(R.id.numEt2); calculateBtn = (Button) findViewById(R.id.calculateBtn); calculateBtn.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View arg0) &#123; gotoCalculate(); &#125; &#125;); Intent intent = new Intent("com.demoserver.CalculateService"); bindService(intent, conn, Context.BIND_AUTO_CREATE); &#125; private void gotoCalculate() &#123; double num1 = Double.parseDouble(numEt1.getText().toString()); double num2 = Double.parseDouble(numEt2.getText().toString()); try &#123; String text = "Sum=" + mService.doCalculate(num1, num2); Toast.makeText(MainActivity.this, text, Toast.LENGTH_LONG).show(); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; 隐式启动服务，可以完成计算求和功能。 3.使用 Android Studio 编写 client 代码的不同之处：目录结构：需要建一个文件夹，名为 aidl，和java文件夹同级，这里面的Calculate.aidl的包名和内容都和 service 端相同。然后手动 rebuild 一下，可以看到自动生成的 java 文件：启动服务时，5.0 以上的系统会报错： 1234java.lang.RuntimeException: Unable to start activity ComponentInfo&#123;lpj.com.tests/lpj.com.tests.MainActivity&#125;: java.lang.IllegalArgumentException: Service Intent must be explicit: Intent &#123; act=com.demoserver.CalculateService &#125; 因为隐式启动服务需要告诉 Intent 包名： 123Intent intent = new Intent("com.demoserver.CalculateService");intent.setPackage("com.demoserver");bindService(intent, conn, Context.BIND_AUTO_CREATE); 多加这句intent.setPackage(&quot;com.demoserver&quot;)就 OK 了。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>aidl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓原生和 H5 交互]]></title>
    <url>%2FAndroid%2Fandroidh5%2F</url>
    <content type="text"><![CDATA[1.安卓调用 H5 的方法：1mWebView.loadUrl("javascript:webViewNotice(" + "'" + messageNum + "'" + ")"); 其中，webViewNotice是方法名，messageNum是原生传给 H5 的参数。安全起见，mWebView 最好判空一下。 2.H5调用安卓原生的方法：123456789WebSettings settings = webView.getSettings();settings.setJavaScriptEnabled(true); // 开启Javascript支持settings.setUseWideViewPort(false);// 将图片调整到适合webview的大小settings.setSupportZoom(true);// 支持缩放settings.setLoadsImagesAutomatically(true); // 设置可以自动加载图片settings.setCacheMode(WebSettings.LOAD_DEFAULT); // 关闭webview中缓存settings.setDomStorageEnabled(true); // 设置DOM缓存webView.setWebChromeClient(new MyWebChromeClient());webView.addJavascriptInterface(new JsObject(context), "javaToJs"); 这其中 settings.setJavaScriptEnabled(true)必须要有，允许在 WebView 中使用 js；MyWebChromeClient 是 WebChromeClient 的子类；javaToJs是原生定义给 H5 使用的对象，JsObject 代码如下： 123456789101112131415161718192021222324252627public class JsObject &#123; public JsObject(Context context) &#123; this.mContext = context; &#125; /** * 跳转界面 */ @JavascriptInterface public void start(String flag, String param) &#123; &#125; /** * 自动注册返回结果 */ @JavascriptInterface public void getResult(String result) &#123; &#125; /** * 退出当前界面 */ @JavascriptInterface public void exit() &#123; &#125;&#125; start、getResult、exit都是定义给 H5 调用的方法。其中每个方法上面的 @JavascriptInterface都是必须的。H5 方面的部分代码为： 1window.javaToJs.getResult("hello");]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>webview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两种方式处理 ViewPager 点击事件]]></title>
    <url>%2FAndroid%2Fviewpager%2F</url>
    <content type="text"><![CDATA[我们知道，ViewPager 没有点击事件，许多时候，需要设置点击事件，比如轮询广告点击事件，这时候怎么处理呢？我总结了两种方式： 对 ViewPager 的每个页面设置点击事件 通过onTouch()方法处理 下面分别说明一下： （一）对 ViewPager 的每个页面设置点击事件比如这种广告轮询，如果想要点击进入，就要给详情页面传入一个id，详情页通过网址+id（比如www.xxxxx/id）访问数据。那么，首先要说明的是这个是 ViewPager + Fragment 做的，适配器用的是 PagerAdapter（后来我也尝试了用 FragmentStatePagerAdapter，下面会说明）。 效果图： 代码如下： 123456789101112@Override public Object instantiateItem(final ViewGroup container, final int position) &#123; View view = viewList.get(position); **view.setOnClickListener**(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; callBack.callBack(position); &#125; &#125;); container.addView(view); return view; &#125; 直接给填充 Fragment 的视图设置点击事件，我这里用了一个回调（这个模式不懂的话自己查一下，不是很难），直接在在回调处做事件处理： 123456@Override public void callBack(int position) &#123; Intent intent = new Intent(getActivity(), TeaDetailsActivity.class); intent.putExtra("id", adList.get(position).getId()); startActivity(intent); &#125; 【注】如果用的适配器是FragmentStatePagerAdapter，因为它没有instantiateItem()方法，则可以在Fragment的onCreateView()中设置点击事件。 （二）通过onTouch()方法处理首先说明，我参考了关于ViewPager的点击事件的处理(感谢作者)，这篇文章思路是，点下屏幕时，设置一个flag为0，移动时为-1，抬起手指时，如果 flag==-1 说明是滑动事件（用于切换 ViewPgaer），此时不触发单击事件（用户滑动界面而非点击进入详情）；如果 flag==0，则说明是单击事件。 说真的，我试了，结果不行。可能和机型有关吧，我用的是 Android7.0 系统，我 debug 的时候，发现无论怎么点击，都会触发移动的动作： 123case MotionEvent.ACTION_MOVE: flag = -1 ; break ; 此时，我在 MotionEvent.ACTION_UP 里面写的代码都没有调用： 123if (flag == 0) &#123;//debug的时候发现 flag == -1//代码操作&#125; 于是我尝试在 MotionEvent.ACTION_DOWN 和 MotionEvent.ACTION_MOVE 的时候分别打印当前的坐标 x，y 值，我发现 x，y 的值都没有变化，就是说，即使手指在屏幕上没有滑动，也会触发 MotionEvent.ACTION_MOVE 事件。 怎么办呢？我请教了我的基友（下面简称他为黄），黄先是查看ViewPager类中的源码，有一块是关于ViewPager点击事件的： 123456789101112131415161718192021222324252627282930case MotionEvent.ACTION_MOVE: if (!mIsBeingDragged) &#123; final int pointerIndex = MotionEventCompat.findPointerIndex(ev, mActivePointerId); if (pointerIndex == -1) &#123; // A child has consumed some touch events and put us into an inconsistent state. needsInvalidate = resetTouch(); break; &#125; final float x = MotionEventCompat.getX(ev, pointerIndex); final float xDiff = Math.abs(x - mLastMotionX); final float y = MotionEventCompat.getY(ev, pointerIndex); final float yDiff = Math.abs(y - mLastMotionY); if (DEBUG) Log.v(TAG, "Moved x to " + x + "," + y + " diff=" + xDiff + "," + yDiff); if (xDiff &gt; mTouchSlop &amp;&amp; xDiff &gt; yDiff) &#123; if (DEBUG) Log.v(TAG, "Starting drag!"); mIsBeingDragged = true; requestParentDisallowInterceptTouchEvent(true); mLastMotionX = x - mInitialMotionX &gt; 0 ? mInitialMotionX + mTouchSlop : mInitialMotionX - mTouchSlop; mLastMotionY = y; setScrollState(SCROLL_STATE_DRAGGING); setScrollingCacheEnabled(true); // Disallow Parent Intercept, just in case ViewParent parent = getParent(); if (parent != null) &#123; parent.requestDisallowInterceptTouchEvent(true); &#125; &#125; &#125; 有一点长，其中有一个变量叫做 mTouchSlop ，对于它的处理很容易理解： 123if (xDiff &gt; mTouchSlop &amp;&amp; xDiff &gt; yDiff) &#123;//一些操作&#125; xDiff 和 yDiff 是 x 和 y 方向上的移动距离（取绝对值），左右滑动时，x 方向上的变化值大于 mTouchSlop ，而且 xDiff 应该大于 yDiff （上下滑动视为无效），黄跟我说，他猜这个 mTouchSlop 应该就是判断ViewPager是否切换页面的滑动临界值，左右滑动超过这个值，页面就会滑到上一个或者下一个界面（看你往哪个方向滑了）。 至此，黄说对我说，如果不想干扰 ViewPager 的滑动事件，又想给 ViewPager 设置点击事件，可以在 mTouchSlop 上面做一些操作。简单的讨论之后，我们就搞定了： 123456789101112131415161718192021222324252627282930313233headVp.setOnTouchListener(new View.OnTouchListener() &#123; int touchFlag = 0; float x = 0, y = 0; @Override public boolean onTouch(View v, MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: touchFlag = 0; x = event.getX(); y = event.getY(); break; case MotionEvent.ACTION_MOVE: float xDiff = Math.abs(event.getX() - x); float yDiff = Math.abs(event.getY() - y); if (xDiff &lt; mTouchSlop &amp;&amp; xDiff &gt;= yDiff) touchFlag = 0; else touchFlag = -1; break; case MotionEvent.ACTION_UP: if (touchFlag == 0) &#123; int currentItem = headVp.getCurrentItem(); Intent it = new Intent(); it.setClass(getActivity(), NewsDetailsActivity.class); it.putExtra("story_id", topStories.get(currentItem).getId()); startActivity(it); &#125; break; &#125; return false; &#125; &#125;); 对了！黄还教了我如何取到 mTouchSlop 的值（也是源码当中的）： 12ViewConfiguration configuration = ViewConfiguration.get(context);mTouchSlop = ViewConfigurationCompat.getScaledPagingTouchSlop(configuration); 至此，问题就都解决了。最后附上项目代码：茶百科逼乎日报]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>viewpager</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线形布局下的layout_weight（比重）属性]]></title>
    <url>%2FAndroid%2Fweight%2F</url>
    <content type="text"><![CDATA[在布局文件中设置layout_weight（比重）属性时，以宽为例，假如 android:layout_width=&quot;wrap_content&quot;,或者 android:layout_width=&quot;0dp&quot;，此时，设置的layout_weight属性和数值成正比；假如 android:layout_width=&quot;match_parent&quot;，此时，设置的layout_weight属性和数值成反比。 具体说明： 123456789101112131415161718192021&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="horizontal"&gt; &lt;LinearLayout android:layout_marginTop="50dp" android:layout_width="wrap_content" android:layout_height="20dp" android:background="#00f" android:layout_weight="1" &gt;&lt;/LinearLayout&gt; &lt;LinearLayout android:layout_marginTop="50dp" android:layout_width="wrap_content" android:layout_height="20dp" android:background="#0f0" android:layout_weight="2" &gt;&lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 效果是这样的：将android:layout_width=&quot;wrap_content&quot;设置为android:layout_width=&quot;0dp&quot;效果和上图相同。 但是，假如布局文件是： 1234567891011121314151617181920&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="horizontal"&gt; &lt;LinearLayout android:layout_marginTop="50dp" android:layout_width="match_parent" android:layout_height="20dp" android:background="#00f" android:layout_weight="1" &gt;&lt;/LinearLayout&gt; &lt;LinearLayout android:layout_marginTop="50dp" android:layout_width="match_parent" android:layout_height="20dp" android:background="#0f0" android:layout_weight="2" &gt;&lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 效果是：这是为什么呢？下面具体说明：首先要理解layout_weight属性的定义：按比例分摊剩余父布局。第一种情况下，宽度为 0dp，所以剩余空间就是一个父布局的宽度（下面简称父宽），蓝色占的比重是 1，绿色是 2，它们的宽度就是 1：2，很好理解；说说第二种情况：蓝色宽度是match_parent，也就是 1 个父宽，绿色宽度也是match_parent，也是 1 个父宽，蓝色和绿色加起来是 2 个父宽，那么，剩余父布局就是：1 父宽 - 2 父宽 = -1 父宽，它们俩要按比例分摊这 -1 父宽，蓝色是 -1 * 1/3 = -1/3 父宽，绿色是 -1 * 2/3 = -2/3 父宽，蓝色原来占 1 父宽，所以最终结果是：1 父宽 + (-1/3 父宽) = 2/3 父宽，绿色最终结果是：1 父宽 + (-2/3 父宽) = 1/3 父宽，2/3 ：1/3 = 2：1，也就是第二幅图的效果了。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>weight</tag>
      </tags>
  </entry>
</search>
